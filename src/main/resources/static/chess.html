<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中国象棋 - 经典国粹</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
    /* 全局样式 */
    body {
      background-color: #f8f9fa;
      background-image: radial-gradient(#e0e0e0 1px, transparent 0);
      background-size: 30px 30px;
      font-family: 'Noto Sans SC', 'PingFang SC', 'Microsoft YaHei', sans-serif;
    }

    .container {
      max-width: 1200px;
    }

    /* 棋盘样式 */
    .chessboard {
      position: relative;
      background-color: #deb887;
      background-image:
        linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 0),
        linear-gradient(rgba(0,0,0,0.1) 1px, transparent 0);
      background-size: 60px 60px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      border: 10px solid #8b4513;
      border-radius: 8px;
      transition: all 0.3s ease;
    }

    .chessboard:hover {
      box-shadow: 0 12px 32px rgba(0,0,0,0.2);
    }

    /* 棋盘线条和九宫格 */
    .board-line {
      position: absolute;
      background-color: #333;
      z-index: 1;
    }

    .board-vertical {
      width: 1px;
      height: 100%;
    }

    .board-horizontal {
      height: 1px;
      width: 100%;
    }

    .palace {
      position: absolute;
      border: 1px solid #333;
      z-index: 2;
    }

    /* 棋子样式 */
    .piece {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s ease;
      z-index: 10;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      user-select: none;
    }

    .piece:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }

    .piece.active {
      transform: scale(1.1);
      box-shadow: 0 0 15px 2px rgba(255, 215, 0, 0.8);
      z-index: 15;
    }

    .piece.red {
      background: radial-gradient(circle at 35% 35%, #ffcccc, #cc0000);
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    .piece.black {
      background: radial-gradient(circle at 35% 35%, #666666, #000000);
      color: #fff;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
    }

    /* 标记点样式 */
    .mark {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: rgba(255, 215, 0, 0.7);
      transform: translate(-50%, -50%);
      z-index: 5;
      transition: all 0.2s ease;
      display: none;
    }

    .mark:hover {
      background-color: rgba(255, 215, 0, 0.9);
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* 游戏信息面板 */
    .game-info {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 15px;
      margin-bottom: 20px;
    }

    .player-turn {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .player-turn.red {
      background-color: #cc0000;
      box-shadow: 0 0 10px 2px rgba(204, 0, 0, 0.5);
    }

    .player-turn.black {
      background-color: #000000;
      box-shadow: 0 0 10px 2px rgba(0, 0, 0, 0.5);
    }

    /* 控制按钮 */
    .control-btn {
      transition: all 0.2s ease;
    }

    .control-btn:hover {
      transform: translateY(-2px);
    }

    /* 响应式设计 */
    @media (max-width: 768px) {
      .chessboard {
        width: 100%;
        height: auto;
        aspect-ratio: 9/10;
      }

      .piece {
        width: 10vw;
        height: 10vw;
        font-size: 4vw;
      }
    }

    /* 动画效果 */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .king-in-check {
      animation: pulse 1s infinite;
    }

    /* 游戏结果弹窗 */
    .result-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #fff;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    }

    /* 历史记录面板 */
    .history-panel {
      max-height: 400px;
      overflow-y: auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 15px;
    }

    .move-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      transition: all 0.2s ease;
    }

    .move-item:hover {
      background-color: #f8f9fa;
      transform: translateX(5px);
    }

    .move-item.current {
      background-color: #e9f7fe;
      font-weight: bold;
    }
  </style>
</head>
<body>
<div class="container mt-5 mb-5">
    <div class="row justify-content-center">
        <div class="col-md-8">
            <h1 class="text-center mb-4 text-dark">中国象棋</h1>

            <div class="game-info mb-4">
                <div class="row">
                    <div class="col-md-6">
                        <h5>当前回合: <span id="current-player"><span class="player-turn red"></span>红方</span></h5>
                    </div>
                    <div class="col-md-6 text-right">
                        <button id="restart-btn" class="btn btn-primary control-btn">
                            <i class="fas fa-redo"></i> 重新开始
                        </button>
                        <button id="undo-btn" class="btn btn-secondary control-btn ml-2">
                            <i class="fas fa-undo"></i> 悔棋
                        </button>
                    </div>
                </div>
            </div>

            <!-- 棋盘容器 -->
            <div class="chessboard mx-auto" id="chessboard" style="width: 540px; height: 600px;">
                <!-- 棋盘将由JavaScript动态生成 -->
            </div>

            <!-- 游戏状态栏 -->
            <div class="game-info mt-4">
                <h5 id="game-status" class="text-center text-success">游戏进行中</h5>
            </div>
        </div>

        <div class="col-md-4 mt-4 mt-md-0">
            <div class="history-panel">
                <h4 class="text-center mb-3">走子记录</h4>
                <div id="move-history" class="text-center">
                    <!-- 走子记录将由JavaScript动态生成 -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 游戏结果弹窗 -->
<div class="result-modal" id="result-modal">
    <div class="modal-content">
        <h2 id="result-text" class="mb-4"></h2>
        <button id="new-game-btn" class="btn btn-success">开始新游戏</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
      // 游戏配置
      const config = {
        boardSize: { width: 540, height: 600 },
        gridSize: 60,
        pieceSize: 50,
        rows: 10,
        cols: 9
      };

      // 游戏状态
      const gameState = {
        currentPlayer: 'red', // 'red' 或 'black'
        selectedPiece: null,
        possibleMoves: [],
        gameOver: false,
        moveCount: 0,
        history: []
      };

      // 棋子类型和初始布局
      const pieceTypes = {
        'r_king': { name: '帅', limit: 'palace', move: 'king' },
        'r_advisor': { name: '仕', limit: 'palace', move: 'diagonal' },
        'r_elephant': { name: '相', limit: 'half', move: 'elephant' },
        'r_horse': { name: '马', move: 'horse' },
        'r_chariot': { name: '車', move: 'chariot' },
        'r_cannon': { name: '炮', move: 'cannon' },
        'r_pawn': { name: '兵', move: 'pawn' },

        'b_king': { name: '将', limit: 'palace', move: 'king' },
        'b_advisor': { name: '士', limit: 'palace', move: 'diagonal' },
        'b_elephant': { name: '象', limit: 'half', move: 'elephant' },
        'b_horse': { name: '马', move: 'horse' },
        'b_chariot': { name: '車', move: 'chariot' },
        'b_cannon': { name: '炮', move: 'cannon' },
        'b_pawn': { name: '卒', move: 'pawn' }
      };

      // 初始棋盘布局
      const initialLayout = [
        ['r_chariot', 'r_horse', 'r_elephant', 'r_advisor', 'r_king', 'r_advisor', 'r_elephant', 'r_horse', 'r_chariot'],
        [null, null, null, null, null, null, null, null, null],
        [null, 'r_cannon', null, null, null, null, null, 'r_cannon', null],
        ['r_pawn', null, 'r_pawn', null, 'r_pawn', null, 'r_pawn', null, 'r_pawn'],
        [null, null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null, null],
        ['b_pawn', null, 'b_pawn', null, 'b_pawn', null, 'b_pawn', null, 'b_pawn'],
        [null, 'b_cannon', null, null, null, null, null, 'b_cannon', null],
        [null, null, null, null, null, null, null, null, null],
        ['b_chariot', 'b_horse', 'b_elephant', 'b_advisor', 'b_king', 'b_advisor', 'b_elephant', 'b_horse', 'b_chariot']
      ];

      // DOM元素
      const chessboard = document.getElementById('chessboard');
      const currentPlayerEl = document.getElementById('current-player');
      const gameStatusEl = document.getElementById('game-status');
      const resultModal = document.getElementById('result-modal');
      const resultText = document.getElementById('result-text');
      const newGameBtn = document.getElementById('new-game-btn');
      const restartBtn = document.getElementById('restart-btn');
      const undoBtn = document.getElementById('undo-btn');
      const moveHistoryEl = document.getElementById('move-history');

      // 初始化棋盘
      let board = [];
      let pieces = [];

      // 初始化游戏
      function initGame() {
        // 清空棋盘
        chessboard.innerHTML = '';

        // 重置游戏状态
        gameState.currentPlayer = 'red';
        gameState.selectedPiece = null;
        gameState.possibleMoves = [];
        gameState.gameOver = false;
        gameState.moveCount = 0;
        gameState.history = [];

        // 更新UI
        updatePlayerIndicator();
        gameStatusEl.textContent = '游戏进行中';
        gameStatusEl.className = 'text-center text-success';
        resultModal.style.display = 'none';
        moveHistoryEl.innerHTML = '';

        // 创建棋盘线条
        createBoardLines();

        // 初始化棋盘数据
        board = JSON.parse(JSON.stringify(initialLayout));

        // 创建棋子
        pieces = [];
        for (let row = 0; row < config.rows; row++) {
          for (let col = 0; col < config.cols; col++) {
            const pieceType = board[row][col];
            if (pieceType) {
              createPiece(pieceType, row, col);
            }
          }
        }

        // 添加事件监听器
        chessboard.addEventListener('click', handleBoardClick);
        newGameBtn.addEventListener('click', initGame);
        restartBtn.addEventListener('click', initGame);
        undoBtn.addEventListener('click', undoMove);
      }

      // 创建棋盘线条和标记
      function createBoardLines() {
        // 创建垂直线
        for (let col = 0; col < config.cols; col++) {
          const line = document.createElement('div');
          line.className = 'board-line board-vertical';
          line.style.left = `${col * config.gridSize + config.gridSize / 2}px`;
          chessboard.appendChild(line);
        }

        // 创建水平线
        for (let row = 0; row < config.rows; row++) {
          const line = document.createElement('div');
          line.className = 'board-line board-horizontal';
          line.style.top = `${row * config.gridSize + config.gridSize / 2}px`;

          // 河界处理
          if (row === 4 || row === 5) {
            line.style.width = '0';
            line.style.left = '50%';

            // 绘制河界文字
            const riverText = document.createElement('div');
            riverText.className = 'position-absolute text-center w-100 text-muted';
            riverText.style.top = `${row * config.gridSize + config.gridSize / 2 - 15}px`;
            riverText.style.fontSize = '14px';
            riverText.textContent = row === 4 ? '楚河' : '汉界';
            chessboard.appendChild(riverText);
          }

          chessboard.appendChild(line);
        }

        // 创建九宫格
        // 上方九宫格
        const upperPalace = document.createElement('div');
        upperPalace.className = 'palace';
        upperPalace.style.left = `${3 * config.gridSize}px`;
        upperPalace.style.top = `${0 * config.gridSize}px`;
        upperPalace.style.width = `${3 * config.gridSize}px`;
        upperPalace.style.height = `${3 * config.gridSize}px`;
        chessboard.appendChild(upperPalace);

        // 下方九宫格
        const lowerPalace = document.createElement('div');
        lowerPalace.className = 'palace';
        lowerPalace.style.left = `${3 * config.gridSize}px`;
        lowerPalace.style.top = `${7 * config.gridSize}px`;
        lowerPalace.style.width = `${3 * config.gridSize}px`;
        lowerPalace.style.height = `${3 * config.gridSize}px`;
        chessboard.appendChild(lowerPalace);

        // 创建棋子位置标记点
        for (let row = 0; row < config.rows; row++) {
          for (let col = 0; col < config.cols; col++) {
            // 跳过河界位置
            if ((row === 4 || row === 5) && (col === 1 || col === 7)) {
              continue;
            }

            const mark = document.createElement('div');
            mark.className = 'mark';
            mark.dataset.row = row;
            mark.dataset.col = col;
            mark.style.left = `${col * config.gridSize + config.gridSize / 2}px`;
            mark.style.top = `${row * config.gridSize + config.gridSize / 2}px`;
            chessboard.appendChild(mark);
          }
        }
      }

      // 创建棋子
      function createPiece(pieceType, row, col) {
        const [color, type] = pieceType.split('_');
        const pieceInfo = pieceTypes[pieceType];

        const piece = document.createElement('div');
        piece.className = `piece ${color}`;
        piece.dataset.type = pieceType;
        piece.dataset.row = row;
        piece.dataset.col = col;
        piece.textContent = pieceInfo.name;

        // 计算棋子位置
        const x = col * config.gridSize + (config.gridSize - config.pieceSize) / 2;
        const y = row * config.gridSize + (config.gridSize - config.pieceSize) / 2;

        piece.style.left = `${x}px`;
        piece.style.top = `${y}px`;

        chessboard.appendChild(piece);
        pieces.push(piece);

        // 添加点击事件
        piece.addEventListener('click', function(e) {
          e.stopPropagation();
          selectPiece(piece);
        });

        return piece;
      }

      // 选择棋子
      function selectPiece(piece) {
        // 如果游戏结束，不执行操作
        if (gameState.gameOver) return;

        const pieceType = piece.dataset.type;
        const [color] = pieceType.split('_');

        // 如果点击的是当前玩家的棋子
        if (color === gameState.currentPlayer) {
          // 取消之前选中的棋子
          deselectPiece();

          // 选中当前棋子
          gameState.selectedPiece = piece;
          piece.classList.add('active');

          // 计算可行的移动位置
          const row = parseInt(piece.dataset.row);
          const col = parseInt(piece.dataset.col);
          gameState.possibleMoves = getPossibleMoves(pieceType, row, col);

          // 显示可行的移动位置
          showPossibleMoves(gameState.possibleMoves);
        }
        // 如果点击的是对方的棋子且已经选中了自己的棋子
        else if (gameState.selectedPiece) {
          const fromRow = parseInt(gameState.selectedPiece.dataset.row);
          const fromCol = parseInt(gameState.selectedPiece.dataset.col);
          const toRow = parseInt(piece.dataset.row);
          const toCol = parseInt(piece.dataset.col);

          // 检查是否可以移动到目标位置
          const move = gameState.possibleMoves.find(move => move.row === toRow && move.col === toCol);
          if (move) {
            movePiece(fromRow, fromCol, toRow, toCol, true);
          }
        }
      }

      // 取消选中棋子
      function deselectPiece() {
        if (gameState.selectedPiece) {
          gameState.selectedPiece.classList.remove('active');
          gameState.selectedPiece = null;
        }

        // 清除可行的移动位置标记
        clearPossibleMoves();
        gameState.possibleMoves = [];
      }

      // 显示可行的移动位置
      function showPossibleMoves(moves) {
        moves.forEach(move => {
          const mark = getMarkAtPosition(move.row, move.col);
          if (mark) {
            mark.style.display = 'block';

            // 添加点击事件
            mark.addEventListener('click', function() {
              const fromRow = parseInt(gameState.selectedPiece.dataset.row);
              const fromCol = parseInt(gameState.selectedPiece.dataset.col);
              movePiece(fromRow, fromCol, move.row, move.col, move.capture);
            });
          }
        });
      }

      // 清除可行的移动位置标记
      function clearPossibleMoves() {
        const marks = chessboard.querySelectorAll('.mark');
        marks.forEach(mark => {
          mark.style.display = 'none';

          // 移除所有事件监听器
          const newMark = mark.cloneNode(true);
          mark.parentNode.replaceChild(newMark, mark);
        });
      }

      // 获取指定位置的标记点
      function getMarkAtPosition(row, col) {
        return chessboard.querySelector(`.mark[data-row="${row}"][data-col="${col}"]`);
      }

      // 获取指定位置的棋子
      function getPieceAtPosition(row, col) {
        return chessboard.querySelector(`.piece[data-row="${row}"][data-col="${col}"]`);
      }

      // 移动棋子
      function movePiece(fromRow, fromCol, toRow, toCol, capture = false) {
        // 获取棋子
        const piece = getPieceAtPosition(fromRow, fromCol);
        if (!piece) return;

        // 记录移动历史
        const pieceType = piece.dataset.type;
        const capturedPiece = capture ? getPieceAtPosition(toRow, toCol) : null;

        gameState.history.push({
          pieceType,
          fromRow,
          fromCol,
          toRow,
          toCol,
          capturedPiece: capturedPiece ? capturedPiece.dataset.type : null,
          moveCount: gameState.moveCount
        });

        // 更新棋盘数据
        board[toRow][toCol] = pieceType;
        board[fromRow][fromCol] = null;

        // 更新DOM
        piece.dataset.row = toRow;
        piece.dataset.col = toCol;

        // 计算新位置
        const x = toCol * config.gridSize + (config.gridSize - config.pieceSize) / 2;
        const y = toRow * config.gridSize + (config.gridSize - config.pieceSize) / 2;

        // 添加动画效果
        piece.style.transition = 'all 0.3s ease';
        piece.style.left = `${x}px`;
        piece.style.top = `${y}px`;

        // 如果是吃子，移除被吃的棋子
        if (capture && capturedPiece) {
          capturedPiece.style.transition = 'all 0.3s ease';
          capturedPiece.style.opacity = '0';
          setTimeout(() => {
            capturedPiece.remove();
          }, 300);
        }

        // 增加移动计数
        gameState.moveCount++;

        // 记录走子
        recordMove(pieceType, fromRow, fromCol, toRow, toCol, capture);

        // 检查游戏状态
        setTimeout(() => {
          checkGameStatus();

          // 切换玩家
          if (!gameState.gameOver) {
            gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'black' : 'red';
            updatePlayerIndicator();
          }

          // 取消选中
          deselectPiece();
        }, 300);
      }

      // 记录走子
      function recordMove(pieceType, fromRow, fromCol, toRow, toCol, capture) {
        const [color, type] = pieceType.split('_');
        const pieceInfo = pieceTypes[pieceType];

        // 转换为象棋记谱法
        const fromPos = `${String.fromCharCode(97 + fromCol)}${10 - fromRow}`;
        const toPos = `${String.fromCharCode(97 + toCol)}${10 - toRow}`;

        const moveText = `${pieceInfo.name}${fromPos}${capture ? '吃' : '到'}${toPos}`;

        // 创建走子记录元素
        const moveItem = document.createElement('div');
        moveItem.className = 'move-item';
        moveItem.textContent = moveText;

        // 添加到历史记录面板
        moveHistoryEl.appendChild(moveItem);

        // 滚动到底部
        moveHistoryEl.scrollTop = moveHistoryEl.scrollHeight;
      }

      // 更新玩家指示器
      function updatePlayerIndicator() {
        const playerText = gameState.currentPlayer === 'red' ? '红方' : '黑方';
        const playerColor = gameState.currentPlayer;

        currentPlayerEl.innerHTML = `<span class="player-turn ${playerColor}"></span>${playerText}`;
      }

      // 检查游戏状态
      function checkGameStatus() {
        // 检查是否将军
        const isCheck = checkCheck();

        if (isCheck) {
          // 检查是否将死
          if (checkCheckmate()) {
            gameState.gameOver = true;
            const winner = gameState.currentPlayer === 'red' ? '黑方' : '红方';
            gameStatusEl.textContent = `${winner}胜利!`;
            gameStatusEl.className = 'text-center text-danger';
            showResultModal(`${winner}胜利!`);
          } else {
            gameStatusEl.textContent = '将军!';
            gameStatusEl.className = 'text-center text-warning';

            // 添加将军动画效果
            const kingColor = gameState.currentPlayer === 'red' ? 'black' : 'red';
            const king = getKing(kingColor);
            if (king) {
              king.classList.add('king-in-check');
            }
          }
        } else {
          gameStatusEl.textContent = '游戏进行中';
          gameStatusEl.className = 'text-center text-success';

          // 移除将军动画效果
          const kings = document.querySelectorAll('.piece.king-in-check');
          kings.forEach(king => {
            king.classList.remove('king-in-check');
          });
        }
      }

      // 检查是否将军
      function checkCheck() {
        // 获取当前玩家的对手
        const opponentColor = gameState.currentPlayer === 'red' ? 'black' : 'red';

        // 获取对手的将/帅位置
        const king = getKing(opponentColor);
        if (!king) return false;

        const kingRow = parseInt(king.dataset.row);
        const kingCol = parseInt(king.dataset.col);

        // 检查当前玩家的所有棋子是否能攻击到对手的将/帅
        for (let row = 0; row < config.rows; row++) {
          for (let col = 0; col < config.cols; col++) {
            const pieceType = board[row][col];
            if (pieceType && pieceType.startsWith(gameState.currentPlayer)) {
              // 检查这个棋子是否能移动到将/帅的位置
              const possibleMoves = getPossibleMoves(pieceType, row, col, true);
              if (possibleMoves.some(move => move.row === kingRow && move.col === kingCol)) {
                return true;
              }
            }
          }
        }

        return false;
      }

      // 检查是否将死
      function checkCheckmate() {
        // 获取当前玩家的对手
        const opponentColor = gameState.currentPlayer === 'red' ? 'black' : 'red';

        // 检查对手是否有任何可行的移动
        for (let row = 0; row < config.rows; row++) {
          for (let col = 0; col < config.cols; col++) {
            const pieceType = board[row][col];
            if (pieceType && pieceType.startsWith(opponentColor)) {
              // 检查这个棋子是否有任何可行的移动
              const possibleMoves = getPossibleMoves(pieceType, row, col);
              if (possibleMoves.length > 0) {
                return false;
              }
            }
          }
        }

        return true;
      }

      // 获取指定颜色的将/帅
      function getKing(color) {
        const kingType = color === 'red' ? 'r_king' : 'b_king';

        for (let row = 0; row < config.rows; row++) {
          for (let col = 0; col < config.cols; col++) {
            if (board[row][col] === kingType) {
              return getPieceAtPosition(row, col);
            }
          }
        }

        return null;
      }

      // 处理棋盘点击
      function handleBoardClick(e) {
        // 如果游戏结束，不执行操作
        if (gameState.gameOver) return;

        // 如果没有选中棋子，不执行操作
        if (!gameState.selectedPiece) return;

        // 获取点击位置的棋盘坐标
        const rect = chessboard.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // 计算最近的交叉点
        const col = Math.round((x - config.gridSize / 2) / config.gridSize);
        const row = Math.round((y - config.gridSize / 2) / config.gridSize);

        // 检查坐标是否有效
        if (row < 0 || row >= config.rows || col < 0 || col >= config.cols) return;

        // 检查是否点击了自己的棋子
        const piece = getPieceAtPosition(row, col);
        if (piece && piece.dataset.type.startsWith(gameState.currentPlayer)) {
          selectPiece(piece);
          return;
        }

        // 检查是否是可行的移动位置
        const move = gameState.possibleMoves.find(move => move.row === row && move.col === col);
        if (move) {
          const fromRow = parseInt(gameState.selectedPiece.dataset.row);
          const fromCol = parseInt(gameState.selectedPiece.dataset.col);
          movePiece(fromRow, fromCol, row, col, move.capture);
        }
      }

      // 获取棋子的可行移动位置
      function getPossibleMoves(pieceType, row, col, ignoreCheck = false) {
        const [color, type] = pieceType.split('_');
        const pieceInfo = pieceTypes[pieceType];
        const moves = [];

        // 根据棋子类型计算可行的移动位置
        switch (pieceInfo.move) {
          case 'king':
            // 将/帅可以上下左右移动一格，且不能出九宫格
            const kingMoves = [
              { row: row - 1, col: col }, // 上
              { row: row + 1, col: col }, // 下
              { row: row, col: col - 1 }, // 左
              { row: row, col: col + 1 }  // 右
            ];

            kingMoves.forEach(move => {
              // 检查是否在棋盘范围内
              if (move.row >= 0 && move.row < config.rows && move.col >= 0 && move.col < config.cols) {
                // 检查是否在九宫格内
                if (isInPalace(move.row, move.col, color)) {
                  // 检查目标位置是否有自己的棋子
                  const targetPiece = board[move.row][move.col];
                  if (!targetPiece || !targetPiece.startsWith(color)) {
                    // 检查是否会导致自己被将军
                    if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, move.row, move.col)) {
                      moves.push({
                        row: move.row,
                        col: move.col,
                        capture: !!targetPiece
                      });
                    }
                  }
                }
              }
            });

            // 将/帅特殊规则：不能与对方将/帅在同一直线上直接相对
            const opponentKing = color === 'red' ? 'b_king' : 'r_king';
            const kingDirection = color === 'red' ? -1 : 1;

            // 检查上下方向是否有对方的将/帅
            for (let r = row + kingDirection; r >= 0 && r < config.rows; r += kingDirection) {
              const targetPiece = board[r][col];
              if (targetPiece === opponentKing) {
                // 检查是否在九宫格内
                if (isInPalace(r, col, color)) {
                  // 检查是否会导致自己被将军
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                    moves.push({
                      row: r,
                      col: col,
                      capture: true
                    });
                  }
                  break;
                }
              } else if (targetPiece) {
                // 如果中间有其他棋子阻挡，不能对将
                break;
              }
            }
            break;

          case 'diagonal':
            // 士/仕可以斜着移动一格，且不能出九宫格
            const diagonalMoves = [
              { row: row - 1, col: col - 1 }, // 左上
              { row: row - 1, col: col + 1 }, // 右上
              { row: row + 1, col: col - 1 }, // 左下
              { row: row + 1, col: col + 1 }  // 右下
            ];

            diagonalMoves.forEach(move => {
              // 检查是否在棋盘范围内
              if (move.row >= 0 && move.row < config.rows && move.col >= 0 && move.col < config.cols) {
                // 检查是否在九宫格内
                if (isInPalace(move.row, move.col, color)) {
                  // 检查目标位置是否有自己的棋子
                  const targetPiece = board[move.row][move.col];
                  if (!targetPiece || !targetPiece.startsWith(color)) {
                    // 检查是否会导致自己被将军
                    if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, move.row, move.col)) {
                      moves.push({
                        row: move.row,
                        col: move.col,
                        capture: !!targetPiece
                      });
                    }
                  }
                }
              }
            });
            break;

          case 'elephant':
            // 象/相可以斜着走两格，但不能过河，且不能被塞象眼
            const elephantMoves = [
              { row: row - 2, col: col - 2, eyeRow: row - 1, eyeCol: col - 1 }, // 左上
              { row: row - 2, col: col + 2, eyeRow: row - 1, eyeCol: col + 1 }, // 右上
              { row: row + 2, col: col - 2, eyeRow: row + 1, eyeCol: col - 1 }, // 左下
              { row: row + 2, col: col + 2, eyeRow: row + 1, eyeCol: col + 1 }  // 右下
            ];

            elephantMoves.forEach(move => {
              // 检查是否在棋盘范围内
              if (move.row >= 0 && move.row < config.rows && move.col >= 0 && move.col < config.cols) {
                // 检查是否过河
                if (!hasCrossedRiver(move.row, color)) {
                  // 检查象眼是否被塞
                  if (!board[move.eyeRow][move.eyeCol]) {
                    // 检查目标位置是否有自己的棋子
                    const targetPiece = board[move.row][move.col];
                    if (!targetPiece || !targetPiece.startsWith(color)) {
                      // 检查是否会导致自己被将军
                      if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, move.row, move.col)) {
                        moves.push({
                          row: move.row,
                          col: move.col,
                          capture: !!targetPiece
                        });
                      }
                    }
                  }
                }
              }
            });
            break;

          case 'horse':
            // 马走日，且不能蹩马腿
            const horseMoves = [
              { row: row - 2, col: col - 1, legRow: row - 1, legCol: col }, // 左上
              { row: row - 2, col: col + 1, legRow: row - 1, legCol: col }, // 右上
              { row: row - 1, col: col - 2, legRow: row, legCol: col - 1 }, // 左前
              { row: row - 1, col: col + 2, legRow: row, legCol: col + 1 }, // 右前
              { row: row + 1, col: col - 2, legRow: row, legCol: col - 1 }, // 左后
              { row: row + 1, col: col + 2, legRow: row, legCol: col + 1 }, // 右后
              { row: row + 2, col: col - 1, legRow: row + 1, legCol: col }, // 左下
              { row: row + 2, col: col + 1, legRow: row + 1, legCol: col }  // 右下
            ];

            horseMoves.forEach(move => {
              // 检查是否在棋盘范围内
              if (move.row >= 0 && move.row < config.rows && move.col >= 0 && move.col < config.cols) {
                // 检查马腿是否被蹩
                if (!board[move.legRow][move.legCol]) {
                  // 检查目标位置是否有自己的棋子
                  const targetPiece = board[move.row][move.col];
                  if (!targetPiece || !targetPiece.startsWith(color)) {
                    // 检查是否会导致自己被将军
                    if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, move.row, move.col)) {
                      moves.push({
                        row: move.row,
                        col: move.col,
                        capture: !!targetPiece
                      });
                    }
                  }
                }
              }
            });
            break;

          case 'chariot':
            // 车可以横竖移动任意距离，但不能跳过其他棋子
            // 向上移动
            for (let r = row - 1; r >= 0; r--) {
              const targetPiece = board[r][col];
              if (!targetPiece) {
                // 空位
                if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                  moves.push({ row: r, col: col, capture: false });
                }
              } else {
                // 遇到棋子
                if (!targetPiece.startsWith(color)) {
                  // 敌方棋子
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                    moves.push({ row: r, col: col, capture: true });
                  }
                }
                break; // 无论敌我，遇到棋子就停止
              }
            }

            // 向下移动
            for (let r = row + 1; r < config.rows; r++) {
              const targetPiece = board[r][col];
              if (!targetPiece) {
                // 空位
                if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                  moves.push({ row: r, col: col, capture: false });
                }
              } else {
                // 遇到棋子
                if (!targetPiece.startsWith(color)) {
                  // 敌方棋子
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                    moves.push({ row: r, col: col, capture: true });
                  }
                }
                break; // 无论敌我，遇到棋子就停止
              }
            }

            // 向左移动
            for (let c = col - 1; c >= 0; c--) {
              const targetPiece = board[row][c];
              if (!targetPiece) {
                // 空位
                if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, c)) {
                  moves.push({ row: row, col: c, capture: false });
                }
              } else {
                // 遇到棋子
                if (!targetPiece.startsWith(color)) {
                  // 敌方棋子
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, c)) {
                    moves.push({ row: row, col: c, capture: true });
                  }
                }
                break; // 无论敌我，遇到棋子就停止
              }
            }

            // 向右移动
            for (let c = col + 1; c < config.cols; c++) {
              const targetPiece = board[row][c];
              if (!targetPiece) {
                // 空位
                if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, c)) {
                  moves.push({ row: row, col: c, capture: false });
                }
              } else {
                // 遇到棋子
                if (!targetPiece.startsWith(color)) {
                  // 敌方棋子
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, c)) {
                    moves.push({ row: row, col: c, capture: true });
                  }
                }
                break; // 无论敌我，遇到棋子就停止
              }
            }
            break;

          case 'cannon':
            // 炮的移动方式与车类似，但吃子需要一个炮架
            // 向上移动
            let cannonMountFound = false;
            for (let r = row - 1; r >= 0; r--) {
              const targetPiece = board[r][col];
              if (!targetPiece) {
                // 空位
                if (!cannonMountFound) {
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                    moves.push({ row: r, col: col, capture: false });
                  }
                }
              } else {
                // 遇到棋子
                if (!cannonMountFound) {
                  cannonMountFound = true;
                } else {
                  // 已经有炮架，遇到第二个棋子
                  if (!targetPiece.startsWith(color)) {
                    // 敌方棋子，可以吃
                    if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                      moves.push({ row: r, col: col, capture: true });
                    }
                  }
                  break; // 无论敌我，遇到第二个棋子就停止
                }
              }
            }

            // 向下移动
            cannonMountFound = false;
            for (let r = row + 1; r < config.rows; r++) {
              const targetPiece = board[r][col];
              if (!targetPiece) {
                // 空位
                if (!cannonMountFound) {
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                    moves.push({ row: r, col: col, capture: false });
                  }
                }
              } else {
                // 遇到棋子
                if (!cannonMountFound) {
                  cannonMountFound = true;
                } else {
                  // 已经有炮架，遇到第二个棋子
                  if (!targetPiece.startsWith(color)) {
                    // 敌方棋子，可以吃
                    if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, r, col)) {
                      moves.push({ row: r, col: col, capture: true });
                    }
                  }
                  break; // 无论敌我，遇到第二个棋子就停止
                }
              }
            }

            // 向左移动
            cannonMountFound = false;
            for (let c = col - 1; c >= 0; c--) {
              const targetPiece = board[row][c];
              if (!targetPiece) {
                // 空位
                if (!cannonMountFound) {
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, c)) {
                    moves.push({ row: row, col: c, capture: false });
                  }
                }
              } else {
                // 遇到棋子
                if (!cannonMountFound) {
                  cannonMountFound = true;
                } else {
                  // 已经有炮架，遇到第二个棋子
                  if (!targetPiece.startsWith(color)) {
                    // 敌方棋子，可以吃
                    if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, c)) {
                      moves.push({ row: row, col: c, capture: true });
                    }
                  }
                  break; // 无论敌我，遇到第二个棋子就停止
                }
              }
            }

            // 向右移动
            cannonMountFound = false;
            for (let c = col + 1; c < config.cols; c++) {
              const targetPiece = board[row][c];
              if (!targetPiece) {
                // 空位
                if (!cannonMountFound) {
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, c)) {
                    moves.push({ row: row, col: c, capture: false });
                  }
                }
              } else {
                // 遇到棋子
                if (!cannonMountFound) {
                  cannonMountFound = true;
                } else {
                  // 已经有炮架，遇到第二个棋子
                  if (!targetPiece.startsWith(color)) {
                    // 敌方棋子，可以吃
                    if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, c)) {
                      moves.push({ row: row, col: c, capture: true });
                    }
                  }
                  break; // 无论敌我，遇到第二个棋子就停止
                }
              }
            }
            break;

          case 'pawn':
            // 兵/卒未过河只能向前走一格，过河后可以左右走一格
            const pawnDirection = color === 'red' ? -1 : 1;

            // 向前走
            const forwardRow = row + pawnDirection;
            if (forwardRow >= 0 && forwardRow < config.rows) {
              const targetPiece = board[forwardRow][col];
              if (!targetPiece) {
                // 空位
                if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, forwardRow, col)) {
                  moves.push({ row: forwardRow, col: col, capture: false });
                }
              } else if (!targetPiece.startsWith(color)) {
                // 敌方棋子，可以吃
                if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, forwardRow, col)) {
                  moves.push({ row: forwardRow, col: col, capture: true });
                }
              }
            }

            // 检查是否过河
            if (hasCrossedRiver(row, color)) {
              // 向左走
              if (col - 1 >= 0) {
                const targetPiece = board[row][col - 1];
                if (!targetPiece) {
                  // 空位
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, col - 1)) {
                    moves.push({ row: row, col: col - 1, capture: false });
                  }
                } else if (!targetPiece.startsWith(color)) {
                  // 敌方棋子，可以吃
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, col - 1)) {
                    moves.push({ row: row, col: col - 1, capture: true });
                  }
                }
              }

              // 向右走
              if (col + 1 < config.cols) {
                const targetPiece = board[row][col + 1];
                if (!targetPiece) {
                  // 空位
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, col + 1)) {
                    moves.push({ row: row, col: col + 1, capture: false });
                  }
                } else if (!targetPiece.startsWith(color)) {
                  // 敌方棋子，可以吃
                  if (ignoreCheck || !wouldCauseCheck(pieceType, row, col, row, col + 1)) {
                    moves.push({ row: row, col: col + 1, capture: true });
                  }
                }
              }
            }
            break;
        }

        return moves;
      }

      // 检查移动是否会导致自己被将军
      function wouldCauseCheck(pieceType, fromRow, fromCol, toRow, toCol) {
        // 模拟移动
        const targetPiece = board[toRow][toCol];
        board[toRow][toCol] = pieceType;
        board[fromRow][fromCol] = null;

        // 检查是否会被将军
        const isCheck = checkCheck();

        // 恢复棋盘
        board[fromRow][fromCol] = pieceType;
        board[toRow][toCol] = targetPiece;

        return isCheck;
      }

      // 检查位置是否在九宫格内
      function isInPalace(row, col, color) {
        if (color === 'red') {
          // 红方九宫格
          return row >= 0 && row <= 2 && col >= 3 && col <= 5;
        } else {
          // 黑方九宫格
          return row >= 7 && row <= 9 && col >= 3 && col <= 5;
        }
      }

      // 检查是否过河
      function hasCrossedRiver(row, color) {
        if (color === 'red') {
          // 红方过河线
          return row <= 4;
        } else {
          // 黑方过河线
          return row >= 5;
        }
      }

      // 显示结果弹窗
      function showResultModal(text) {
        resultText.textContent = text;
        resultModal.style.display = 'flex';
      }

      // 悔棋
      function undoMove() {
        if (gameState.history.length === 0 || gameState.gameOver) return;

        // 获取最后一步移动
        const lastMove = gameState.history.pop();

        // 移除走子记录
        const moveItems = moveHistoryEl.querySelectorAll('.move-item');
        if (moveItems.length > 0) {
          moveItems[moveItems.length - 1].remove();
        }

        // 恢复棋子位置
        const piece = getPieceAtPosition(lastMove.toRow, lastMove.toCol);
        if (piece) {
          piece.dataset.row = lastMove.fromRow;
          piece.dataset.col = lastMove.fromCol;

          // 计算新位置
          const x = lastMove.fromCol * config.gridSize + (config.gridSize - config.pieceSize) / 2;
          const y = lastMove.fromRow * config.gridSize + (config.gridSize - config.pieceSize) / 2;

          piece.style.left = `${x}px`;
          piece.style.top = `${y}px`;
        }

        // 恢复被吃的棋子
        if (lastMove.capturedPiece) {
          createPiece(lastMove.capturedPiece, lastMove.toRow, lastMove.toCol);
        }

        // 恢复棋盘数据
        board[lastMove.fromRow][lastMove.fromCol] = lastMove.pieceType;
        board[lastMove.toRow][lastMove.toCol] = lastMove.capturedPiece || null;

        // 减少移动计数
        gameState.moveCount--;

        // 切换回上一个玩家
        gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'black' : 'red';
        updatePlayerIndicator();

        // 取消选中
        deselectPiece();

        // 重置游戏状态
        gameState.gameOver = false;
        gameStatusEl.textContent = '游戏进行中';
        gameStatusEl.className = 'text-center text-success';
      }

      // 初始化游戏
      initGame();
    });
  </script>
</body>
</html>